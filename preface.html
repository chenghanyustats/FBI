<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.19">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>preface</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="preface_files/libs/clipboard/clipboard.min.js"></script>
<script src="preface_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="preface_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="preface_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="preface_files/libs/quarto-html/popper.min.js"></script>
<script src="preface_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="preface_files/libs/quarto-html/anchor.min.js"></script>
<link href="preface_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="preface_files/libs/quarto-html/quarto-syntax-highlighting-46eeb4c476de49ef7df495821a6125d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="preface_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="preface_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="preface_files/libs/bootstrap/bootstrap-76bc00ab12f34705138908a94282ea05.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="related-textbooks-and-influences" class="level2">
<h2 class="anchored" data-anchor-id="related-textbooks-and-influences">Related textbooks and influences</h2>
<p>This book is part of a broader movement toward model-based and conceptually unified approaches to statistics, and it is influenced by several important texts.</p>
<p>On the <strong>model-based side</strong>, books such as <em>Regression and Other Stories</em> by Gelman, Hill, and Vehtari present regression as a general framework for statistical modeling and emphasize careful model specification, checking, and interpretation. :contentReference<span data-index="0">oaicite:0</span> At a more advanced level, <em>The Elements of Statistical Learning</em> and related machine learning texts take a strongly model-based view of prediction and function estimation, though they are not aimed at introductory audiences.</p>
<p>On the <strong>Bayesian side</strong>, <em>Statistical Rethinking</em> by McElreath is a widely admired introduction to Bayesian data analysis and causal reasoning that is explicitly model-based and pedagogically innovative, but it assumes a dedicated Bayesian course and does not attempt parallel frequentist development. :contentReference<span data-index="1">oaicite:1</span> Other books, such as Russo’s <em>Statistics for the Behavioural Sciences: An Introduction to Frequentist and Bayesian Approaches</em>, introduce both paradigms in the context of psychology and related fields but generally retain a more traditional organization and treat Bayesian material as a complement to a primarily frequentist course. :contentReference<span data-index="2">oaicite:2</span> Wakefield’s <em>Bayesian and Frequentist Regression Methods</em> offers a modern and genuinely parallel treatment of both paradigms, but it focuses on regression and is not intended as a first course in statistics. :contentReference<span data-index="3">oaicite:3</span></p>
<p>To the best of our knowledge, there is currently <strong>no single introductory statistics textbook</strong> that:</p>
<ul>
<li>is explicitly <strong>model-based from the simplest one-mean problem onward</strong>, using a common representation such as<br>
[ Y_i = f(x_i) + _i ] to connect one-sample problems, group comparisons, ANOVA, and regression;</li>
<li>treats <strong>distribution-based frequentist</strong>, <strong>simulation-based</strong>, and <strong>Bayesian</strong> methods as <em>co-equal approaches</em> to the same inferential questions (for example, one mean, two means, one proportion, two proportions, simple regression), within the same chapter; and</li>
<li>systematically includes <strong>nonparametric or distribution-free</strong> methods as robustness tools within that same unified framework.</li>
</ul>
<p>Most existing texts either focus almost entirely on classical frequentist procedures, include simulation only as a supporting or optional tool, or are fully Bayesian with only brief references to frequentist ideas. When both paradigms appear in the same volume, they are typically separated into different chapters or courses and are not consistently applied side by side to each canonical inferential scenario.</p>
<section id="why-this-approach-is-valuable-for-introductory-statistics" class="level3">
<h3 class="anchored" data-anchor-id="why-this-approach-is-valuable-for-introductory-statistics">Why this approach is valuable for introductory statistics</h3>
<p>A model-based, multi-paradigm introduction has several important benefits for introductory statistics courses.</p>
<ol type="1">
<li><p><strong>A unified conceptual framework</strong></p>
<p>By framing every inferential problem in terms of a simple model such as (Y = f(x) + ), students see that:</p>
<ul>
<li>one-sample means are intercept-only models,</li>
<li>two-sample comparisons are regression with a binary predictor,</li>
<li>ANOVA is regression with categorical predictors,</li>
<li>regression itself is an extension rather than a new topic.</li>
</ul>
<p>This reduces the sense that statistics is a collection of unrelated “tests” and instead highlights a small number of recurring ideas about signal, noise, and structure.</p></li>
<li><p><strong>Parallel development of frequentist and Bayesian reasoning</strong></p>
<p>Presenting frequentist and Bayesian methods as responses to the <em>same</em> model and <em>same</em> question helps students understand:</p>
<ul>
<li>what is shared (the data, model, and likelihood), and<br>
</li>
<li>what differs (how parameters are treated, how uncertainty is quantified, how probability statements are interpreted).</li>
</ul>
<p>This clarity is especially important as Bayesian methods become more common in applied research, allowing students to read and critique both kinds of analyses rather than being locked into a single framework.</p></li>
<li><p><strong>Simulation as a bridge, not an afterthought</strong></p>
<p>Simulation-based methods (bootstrap, permutation/randomization, posterior simulation) serve as a common computational language that:</p>
<ul>
<li>builds intuition for sampling variability and the idea of a sampling distribution,</li>
<li>makes abstract theoretical results more concrete,</li>
<li>extends naturally to models and situations where closed-form formulas are unavailable.</li>
</ul>
<p>For many students, simulation is more intuitive than algebraic derivations, and it aligns well with modern data science practice.</p></li>
<li><p><strong>Early and honest discussion of assumptions and robustness</strong></p>
<p>By juxtaposing:</p>
<ul>
<li>distribution-based methods that rely on specific parametric assumptions,</li>
<li>nonparametric distribution-free procedures, and</li>
<li>Bayesian methods that make prior assumptions explicit,</li>
</ul>
<p>the book encourages students to ask:</p>
<ul>
<li>“What assumptions am I making?”</li>
<li>“How sensitive are my conclusions to these assumptions?”</li>
<li>“What alternatives do I have if assumptions are doubtful?”</li>
</ul>
<p>This supports better scientific practice and prepares students to handle messy real-world data.</p></li>
<li><p><strong>Alignment with modern statistical practice and research</strong></p>
<p>In many applied fields, analysts routinely move between frequentist, simulation-based, and Bayesian tools. An introductory course that reflects this reality:</p>
<ul>
<li>better prepares students for advanced coursework in statistics, data science, and machine learning,</li>
<li>makes it easier for them to read contemporary research articles, and</li>
<li>reduces the conceptual gap between introductory material and the methods they will actually see in practice.</li>
</ul></li>
</ol>
<p>In summary, the goal of this book is not simply to “add some Bayes” to a traditional frequentist curriculum, but to provide a <strong>coherent, model-based introduction</strong> in which frequentist, simulation-based, and Bayesian reasoning are presented as complementary ways of learning about unknown parameters from data. This structure aims to give students a deeper and more flexible understanding of statistical inference, right from their first course.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>